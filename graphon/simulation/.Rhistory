# Q2 ----------------------------------------------------------------------
fit.linear.model<-function(covariate,outcome){
X=cbind(1,covariate);
beta.fit=solve( t(X)%*%X )%*%t(X)%*%outcome;
return(beta.fit)
}
beta.hat=fit.linear.model(covariate=x,outcome=y)
beta.hat
coefficients(lm(y~x))
# Q3 ----------------------------------------------------------------------
# functions from sources.r
# linear.model<-...
# sum.of.squares<-...
# estimate.sigma.sq<-...
# estimate.coef.var<-...
# estimate.coef.sd<-...
# estimate.coef.sd(beta.hat,covariate=x,outcome=y)
# my version
estimate_coef_sd = function(covariate, outcome, beta_hat){
X = cbind(1, covariate)
y = outcome
n = length(outcome)
p = length(beta_hat)
y_hat = X %*% beta_hat
residuals = y - y_hat
mse = sum(residuals^2) / (n-p)
var_beta = mse * solve(t(X)%*%X)
sd_beta = sqrt(diag(var_beta))
names(sd_beta) = c("intercept", "slope")
return(sd_beta)
}
estimate_coef_sd(covariate = x, outcome = y, beta_hat = beta.hat)
summary(lm(y~x))$coefficients[,2]
# function from Gitbook
boot.fit<-function(covariate,outcome){
n=length(outcome);
sample_indices = sample(1:n,n,replace=TRUE) # sampling with replacement
covariate.boot= covariate[sample_indices]; outcome.boot= outcome[sample_indices];
beta.hat=fit.linear.model(covariate=covariate.boot,outcome=outcome.boot);
return(t(beta.hat ))
}
# 100 bootstraps
B = 100
beta.hat.boot = replicate(B, boot.fit(covariate=x,outcome=y))
beta.hat.boot
head(beta.hat.boot)
dim(beta.hat.boot)
replicate
?replicate
replicate(B, boot.fit(covariate=x,outcome=y), simplify = TRUE)
replicate(B, boot.fit(covariate=x,outcome=y), simplify = FALSE)
replicate(B, boot.fit(covariate=x,outcome=y), simplify = TRUE)
head(beta.hat.boot)
dim(beta.hat.boot)
beta.hat.boot = replicate(B, boot.fit(covariate=x,outcome=y), simplify = TRUE)
head(beta.hat.boot)
dim(beta.hat.boot)
apply(beta.hat.boot, 1, quantile, probs=c(alpha/2,1-alpha/2))
# 95% confidence interval
alpha = 0.05
apply(beta.hat.boot, 1, quantile, probs=c(alpha/2,1-alpha/2))
CIs = apply(beta.hat.boot, 1, quantile, probs=c(alpha/2,1-alpha/2))
rownames(CIs) = c("intercept", "slope")
CIs
CIs = apply(beta.hat.boot, 1, quantile, probs=c(alpha/2,1-alpha/2))
colnames(CIs) = c("intercept", "slope")
CIs
CIs[,2]
beta.hat
# Q5 ----------------------------------------------------------------------
# functions from Gitbook
conf.int.quantile<-function(alpha,type,...){
if(type=="t"){
out=qt(c(1-alpha/2,alpha/2), df )
}else if (type=="normal"){
out=qnorm(c(1-alpha/2,alpha/2), ... )
}
return(out)
}
conf.int<-function(alpha,type,covariate,outcome,B=1e5){
beta.hat=fit.linear.model(covariate,outcome);
beta.sd=estimate.coef.sd(beta=beta.hat,covariate,outcome);
if(type=='bootstrap'){
beta.hat.boot=replicate(B,boot.fit(covariate,outcome));
out=t(apply(beta.hat.boot[1,,],1,quantile,probs=c(alpha/2,1-alpha/2)));
}else if(type=='t'){
quants<-conf.int.quantile(alpha,type='t',df=n-2)
out=beta.hat%*%c(1,1)-beta.sd%*%quants;
}else{
quants<-conf.int.quantile(alpha,type='normal')
out=beta.hat%*%c(1,1)-beta.sd%*%quants;
}
colnames(out)=c( paste(round(alpha*50,digits=3),'%'), paste(100-round(alpha*50,digits=3),'%')  )
rownames(out)=c('(Intercept)','Slope')
return(out)
}
simulate.one.instance<-function(x,alpha){
n=length(x);
y=x*0.05+24+rnorm(n);
CIs=conf.int(alpha=alpha,type='z',covariate=x,outcome=y);
return(CIs)
}
alpha=0.06
N.sim=10000;
set.seed(23429)
n=30;
x=runif(n,min=16,max=160);
beta.true=c(20,0.15)
sim.CIs=replicate(N.sim,simulate.one.instance(x,alpha));
coverage=sum(sim.CIs[2,1,]<0.05 & sim.CIs[2,2,]>0.05)/N.sim;
coverage
source("~/Dropbox/Spring2020/Homework/sources.r")
# Q5 ----------------------------------------------------------------------
# functions from Gitbook
conf.int.quantile<-function(alpha,type,...){
if(type=="t"){
out=qt(c(1-alpha/2,alpha/2), df )
}else if (type=="normal"){
out=qnorm(c(1-alpha/2,alpha/2), ... )
}
return(out)
}
conf.int<-function(alpha,type,covariate,outcome,B=1e5){
beta.hat=fit.linear.model(covariate,outcome);
beta.sd=estimate.coef.sd(beta=beta.hat,covariate,outcome);
if(type=='bootstrap'){
beta.hat.boot=replicate(B,boot.fit(covariate,outcome));
out=t(apply(beta.hat.boot[1,,],1,quantile,probs=c(alpha/2,1-alpha/2)));
}else if(type=='t'){
quants<-conf.int.quantile(alpha,type='t',df=n-2)
out=beta.hat%*%c(1,1)-beta.sd%*%quants;
}else{
quants<-conf.int.quantile(alpha,type='normal')
out=beta.hat%*%c(1,1)-beta.sd%*%quants;
}
colnames(out)=c( paste(round(alpha*50,digits=3),'%'), paste(100-round(alpha*50,digits=3),'%')  )
rownames(out)=c('(Intercept)','Slope')
return(out)
}
simulate.one.instance<-function(x,alpha){
n=length(x);
y=x*0.05+24+rnorm(n);
CIs=conf.int(alpha=alpha,type='z',covariate=x,outcome=y);
return(CIs)
}
alpha=0.06
N.sim=10000;
set.seed(23429)
n=30;
x=runif(n,min=16,max=160);
beta.true=c(20,0.15)
sim.CIs=replicate(N.sim,simulate.one.instance(x,alpha));
coverage=sum(sim.CIs[2,1,]<0.05 & sim.CIs[2,2,]>0.05)/N.sim;
coverage
simulate.one.instance
source("~/Dropbox/Spring2020/Homework/sources.r")
simulate.one.instance
# my version
simulate_one_instance = function(covariate, beta_true, alpha, sigma){
n = nrow(covariate)
errors = rnorm(n, 0, sigma)
X = cbind(1, covariate)
y = X %*% beta_true + errors
beta_hat = solve(t(X)%*%X) %*% t(X) %*% y
residuals = y - y_hat
mse = sum(residuals^2) / (n-ncol(X))
var_beta = mse * solve(t(X)%*%X)
sd_beta = sqrt(diag(var_beta))
upper_bound = beta_hat + qnorm(1-alpha/2) * sd_beta
lower_bound = beta_hat - qnorm(1-alpha/2) * sd_beta
CI = rbind(lower_bound, upper_bound)
rownames(CI) = c(alpha/2, 1-alpha/2)
colnames(CI) = c("Intercept", "Slope")
return(CI)
}
beta_true=c(0.5, 10)
simulate_one_instance(x, beta_true, alpha, 1.5)
simulate_one_instance(x, beta_true, alpha, sigma=1.5)
sigma=1.5
rnorm(n, 0, sigma)
x
beta_true
alpha
debugSource('~/Documents/Academic/TA/SAT108_SQ2020/Discussion/Discussion3/Discussion3.R')
covariate
beta_true
alpha
sigma
n = nrow(covariate)
errors = rnorm(n, 0, sigma)
sigma
nrow(covariate)
covariate
debugSource('~/Documents/Academic/TA/SAT108_SQ2020/Discussion/Discussion3/Discussion3.R')
covariate
# my version
simulate_one_instance = function(covariate, beta_true, alpha, sigma){
X = cbind(1, covariate)
n = nrow(X)
errors = rnorm(n, 0, sigma)
y = X %*% beta_true + errors
beta_hat = solve(t(X)%*%X) %*% t(X) %*% y
residuals = y - y_hat
mse = sum(residuals^2) / (n-ncol(X))
var_beta = mse * solve(t(X)%*%X)
sd_beta = sqrt(diag(var_beta))
upper_bound = beta_hat + qnorm(1-alpha/2) * sd_beta
lower_bound = beta_hat - qnorm(1-alpha/2) * sd_beta
CI = rbind(lower_bound, upper_bound)
rownames(CI) = c(alpha/2, 1-alpha/2)
colnames(CI) = c("Intercept", "Slope")
return(CI)
}
simulate_one_instance(x, beta_true, alpha, sigma=1.5)
y_hat = X %*% beta_hat
residuals = y - y_hat
# my version
simulate_one_instance = function(covariate, beta_true, alpha, sigma){
X = cbind(1, covariate)
n = nrow(X)
errors = rnorm(n, 0, sigma)
y = X %*% beta_true + errors
beta_hat = solve(t(X)%*%X) %*% t(X) %*% y
y_hat = X %*% beta_hat
residuals = y - y_hat
mse = sum(residuals^2) / (n-ncol(X))
var_beta = mse * solve(t(X)%*%X)
sd_beta = sqrt(diag(var_beta))
upper_bound = beta_hat + qnorm(1-alpha/2) * sd_beta
lower_bound = beta_hat - qnorm(1-alpha/2) * sd_beta
CI = rbind(lower_bound, upper_bound)
rownames(CI) = c(alpha/2, 1-alpha/2)
colnames(CI) = c("Intercept", "Slope")
return(CI)
}
simulate_one_instance(x, beta_true, alpha, sigma=1.5)
debugSource('~/Documents/Academic/TA/SAT108_SQ2020/Discussion/Discussion3/Discussion3.R')
sd_beta
beta_hat + qnorm(1-alpha/2) * sd_beta
beta_hat - qnorm(1-alpha/2) * sd_beta
upper_bound = beta_hat + qnorm(1-alpha/2) * sd_beta
lower_bound = beta_hat - qnorm(1-alpha/2) * sd_beta
CI = rbind(lower_bound, upper_bound)
CI
CI = cbind(lower_bound, upper_bound)
CI
rownames(CI) = c(alpha/2, 1-alpha/2)
colnames(CI) = c("Intercept", "Slope")
# my version
simulate_one_instance = function(covariate, beta_true, alpha, sigma){
X = cbind(1, covariate)
n = nrow(X)
errors = rnorm(n, 0, sigma)
y = X %*% beta_true + errors
beta_hat = solve(t(X)%*%X) %*% t(X) %*% y
y_hat = X %*% beta_hat
residuals = y - y_hat
mse = sum(residuals^2) / (n-ncol(X))
var_beta = mse * solve(t(X)%*%X)
sd_beta = sqrt(diag(var_beta))
upper_bound = beta_hat + qnorm(1-alpha/2) * sd_beta
lower_bound = beta_hat - qnorm(1-alpha/2) * sd_beta
CI = cbind(lower_bound, upper_bound)
rownames(CI) = c(alpha/2, 1-alpha/2)
colnames(CI) = c("Intercept", "Slope")
return(CI)
}
simulate_one_instance(x, beta_true, alpha, sigma=1.5)
sd_beta
estimate_coef_sd(covariate = x, outcome = y, beta_hat = beta.hat)
debugSource('~/Documents/Academic/TA/SAT108_SQ2020/Discussion/Discussion3/Discussion3.R')
sd_beta
qnorm(1-alpha/2)
beta_hat
beta_true
X
beta_hat
simulate_one_instance(x, beta_true, alpha, sigma=1.5)
# my version
simulate_one_instance = function(covariate, beta_true, alpha, sigma){
X = cbind(1, covariate)
n = nrow(X)
errors = rnorm(n, 0, sigma)
y = X %*% beta_true + errors
beta_hat = solve(t(X)%*%X) %*% t(X) %*% y
y_hat = X %*% beta_hat
residuals = y - y_hat
mse = sum(residuals^2) / (n-ncol(X))
var_beta = mse * solve(t(X)%*%X)
sd_beta = sqrt(diag(var_beta))
upper_bound = beta_hat + qnorm(1-alpha/2) * sd_beta
lower_bound = beta_hat - qnorm(1-alpha/2) * sd_beta
CI = cbind(lower_bound, upper_bound)
rownames(CI) = c(alpha/2, 1-alpha/2)
colnames(CI) = c("Intercept", "Slope")
return(CI)
}
simulate_one_instance(x, beta_true, alpha, sigma=1.5)
simulate_one_instance(x, beta_true, alpha, sigma=1.5)
simulate_one_instance(x, beta_true, alpha, sigma=1.5)
simulate_one_instance(x, beta_true, alpha, sigma=1.5)
simulate_one_instance(x, beta_true, alpha, sigma=1.5)
simulate_one_instance(x, beta_true, alpha, sigma=1.5)
debugSource('~/Documents/Academic/TA/SAT108_SQ2020/Discussion/Discussion3/Discussion3.R')
sd_beta
qnorm(1-alpha/2)
# my version
simulate_one_instance = function(covariate, beta_true, alpha, sigma){
X = cbind(1, covariate)
n = nrow(X)
errors = rnorm(n, 0, sigma)
y = X %*% beta_true + errors
beta_hat = solve(t(X)%*%X) %*% t(X) %*% y
y_hat = X %*% beta_hat
residuals = y - y_hat
mse = sum(residuals^2) / (n-ncol(X))
var_beta = mse * solve(t(X)%*%X)
sd_beta = sqrt(diag(var_beta))
upper_bound = beta_hat + qnorm(1-alpha/2) * sd_beta
lower_bound = beta_hat - qnorm(1-alpha/2) * sd_beta
CI = t(cbind(lower_bound, upper_bound))
rownames(CI) = c(alpha/2, 1-alpha/2)
colnames(CI) = c("Intercept", "Slope")
return(CI)
}
simulate_one_instance(x, beta_true, alpha, sigma=1.5)
replicate(N.sim,simulate_one_instance(x, beta_true, alpha, sigma), simplify = TRUE)
sim.CIs=replicate(N.sim,simulate_one_instance(x, beta_true, alpha, sigma))
sim.CIs
beta_true=c(10, 0.5)
sigma = 1.5
sim.CIs=replicate(N.sim,simulate_one_instance(x, beta_true, alpha, sigma))
sim.CIs
set.seed(831)
n=10;
x=runif(n,min=10,max=120);
beta_true=c(10, 0.05)
sigma = 1.5
sim.CIs=replicate(N.sim,simulate_one_instance(x, beta_true, alpha, sigma))
sum(sim.CIs[1,2,]<0.05 & sim.CIs[2,2,]>0.05)/N.sim;
coverage=sum(sim.CIs[1,2,]<0.05 & sim.CIs[2,2,]>0.05)/N.sim
coverage
debugSource('~/Documents/Academic/TA/SAT108_SQ2020/Discussion/Discussion3/Discussion3.R')
# Q5 ----------------------------------------------------------------------
# functions from Gitbook
# conf.int.quantile<-...
# conf.int<-...
# simulate.one.instance<-...
# my version
simulate_one_instance = function(covariate, beta_true, alpha, sigma){
X = cbind(1, covariate)
n = nrow(X)
errors = rnorm(n, 0, sigma)
y = X %*% beta_true + errors
beta_hat = solve(t(X)%*%X) %*% t(X) %*% y
y_hat = X %*% beta_hat
residuals = y - y_hat
mse = sum(residuals^2) / (n-ncol(X))
var_beta = mse * solve(t(X)%*%X)
sd_beta = sqrt(diag(var_beta))
upper_bound = beta_hat + qnorm(1-alpha/2) * sd_beta
lower_bound = beta_hat - qnorm(1-alpha/2) * sd_beta
CI = t(cbind(lower_bound, upper_bound))
rownames(CI) = c(alpha/2, 1-alpha/2)
colnames(CI) = c("Intercept", "Slope")
return(CI)
}
alpha=0.05
N.sim=100;
set.seed(831)
n=10;
x=runif(n,min=10,max=120);
beta_true=c(10, 0.05)
sigma = 1.5
sim.CIs=replicate(N.sim,simulate_one_instance(x, beta_true, alpha, sigma))
coverage=sum(sim.CIs[1,2,]<0.05 & sim.CIs[2,2,]>0.05)/N.sim
coverage
coverage=sum(sim.CIs[1,2,]<0.05 && sim.CIs[2,2,]>0.05)/N.sim
coverage
sim.CIs[1,2,]<0.05 && sim.CIs[2,2,]>0.05
sim.CIs[1,2,]<0.05 & sim.CIs[2,2,]>0.05
coverage=sum(sim.CIs[1,2,]<0.05 & sim.CIs[2,2,]>0.05)/N.sim
coverage
source('~/Documents/Academic/TA/SAT108_SQ2020/Discussion/Discussion3/Discussion3.R')
setwd('~')
debugSource('~/Dropbox/Spring2020/Homework/sources.r')
conf.int(0.05, "t", 1:10, 1:10)
debugSource('~/Dropbox/Spring2020/Homework/sources.r')
conf.int(0.05, "t", 1:10, 1:10)
quants
beta.hat
beta.hat%*%c(1,1)
beta.sd%*%quants
beta.sd
quants
beta.hat
knitr::opts_chunk$set(echo = TRUE)
beta.hat
beta.hat%*%c(1,1)
beta.sd%*%quants
conf.int(0.05, "t", 1:10, 1:10)
beta.hat
beta.hat%*%c(1,1)
beta.sd%*%quants
alpha=0.05
type="t"
covariate=1:10
outcome=1:10
beta.hat=fit.linear.model(covariate,outcome);
beta.sd=estimate.coef.sd(beta=beta.hat,covariate,outcome);
quants<-conf.int.quantile(alpha,type='t',df=n-2)
beta.hat
beta.hat%*%c(1,1)
beta.sd%*%quants
beta.hat%*%c(1,1)-beta.sd%*%quants
alpha = 0.05
type = "t"
covariate = 1:10
outcome = 1:10
beta.hat
beta.hat%*%c(1,1) # duplicate beta.hat
beta.sd%*%quants
beta.hat%*%c(1,1)-beta.sd%*%quants #
alpha = 0.05
type = "t"
covariate = 1:10
outcome = 1:10
beta.hat
beta.hat%*%c(1,1) # duplicate beta.hat
beta.sd%*%quants
beta.hat%*%c(1,1)-beta.sd%*%quants #
alpha = 0.05
type = "t"
covariate = 1:10
outcome = 1:10
beta.hat
beta.hat%*%c(1,1) # duplicate beta.hat
beta.sd%*%quants
beta.hat%*%c(1,1)-beta.sd%*%quants #
alpha = 0.05
type = "t"
covariate = 1:10
outcome = 1:10
beta.hat
beta.hat%*%c(1,1) # duplicate beta.hat
beta.sd%*%quants
beta.hat%*%c(1,1)-beta.sd%*%quants #
alpha = 0.05
type = "t"
covariate = 1:10
outcome = 1:10
beta.hat
beta.hat%*%c(1,1) # duplicate beta.hat
beta.sd%*%quants
beta.hat%*%c(1,1)-beta.sd%*%quants #
set.seed(1)
alpha = 0.05
type = "t"
covariate = 1:10
outcome = 1:10
beta.hat
beta.hat%*%c(1,1) # duplicate beta.hat
beta.sd%*%quants
beta.hat%*%c(1,1)-beta.sd%*%quants #
alpha = 0.05
type = "t"
covariate = 1:10
outcome = 1:10
beta.hat
beta.hat%*%c(1,1) # duplicate beta.hat
beta.sd%*%quants
beta.hat%*%c(1,1)-beta.sd%*%quants #
alpha = 0.05
type = "t"
covariate = 1:10
outcome = 1:10
beta.hat
beta.hat%*%c(1,1) # duplicate beta.hat
beta.sd%*%quants
beta.hat%*%c(1,1)-beta.sd%*%quants #
alpha = 0.05
type = "t"
covariate = 1:10
outcome = 1:10
beta.hat
beta.hat%*%c(1,1) # duplicate beta.hat
beta.sd%*%quants
beta.hat%*%c(1,1)-beta.sd%*%quants #
alpha = 0.05
type = "t"
covariate = 1:10
outcome = 1:10
beta.hat
beta.hat%*%c(1,1) # duplicate beta.hat
beta.sd
quants
beta.sd*quants
beta.hat%*%c(1,1)-beta.sd%*%quants # first column: lower bounds; second column: upper bounds
n
alpha = 0.05
type = "t"
covariate = 1:10
outcome = 1:10
beta.hat=fit.linear.model(covariate,outcome);
beta.sd=estimate.coef.sd(beta=beta.hat,covariate,outcome);
quants=conf.int.quantile(alpha,type='t',df=10-2)
beta.hat
beta.hat%*%c(1,1) # duplicate beta.hat
beta.sd
quants # [1] 1-alpha/2 quantile, [2] alpha/2 quantile
beta.sd*quants
beta.hat%*%c(1,1)-beta.sd%*%quants # first column: lower bounds of CIs; second column: upper bounds of CIs
